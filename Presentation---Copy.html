<!DOCTYPE html>
<html lang="" xml:lang="">
  <head>
    <title>Data Science for Economists</title>
    <meta charset="utf-8" />
    <meta name="author" content="Dana Kim" />
    <script src="libs/header-attrs/header-attrs.js"></script>
    <link href="libs/remark-css/default.css" rel="stylesheet" />
    <link href="libs/remark-css/metropolis.css" rel="stylesheet" />
    <link href="libs/remark-css/metropolis-fonts.css" rel="stylesheet" />
  </head>
  <body>
    <textarea id="source">
class: center, middle, inverse, title-slide

.title[
# Data Science for Economists
]
.subtitle[
## S&amp;P 500 Return Prediction: A Data-Driven Approach (1985–2024)
]
.author[
### Dana Kim
]
.date[
### University of North Carolina | <a href="https://github.com/JiaxiLi1995/ECON370">ECON 370</a>
]

---





# Introduction

**Hightlight of the project**:
- Data: 7 macro predictors, 3 financial indicators sourced from 4+ independent datasets, merged to construct monthly S&amp;P 500 return predictors from 1985–2024.
- Model: *Linear Model* as benchmark and *LASSO* as the advanced model
- Achievement: Using the more complex model (LASSO), I was able to improve the predictive performance of the baseline. The predictive OOS R² increased from –0.33 (OLS) to +0.16 (LASSO). LASSO produced smaller residuals and more stable fitted returns, especially during high-volatility periods such as 2008–2009, where OLS failed to generalize. 

---
# Data

Here is a table of data that I am using with brief reasoning:


### Table: Possible Data Related to Stock Returns

| Variable | Type | Reason |
|----------------|------------|-----------------------|
| GDP | Macro | Reflects economic growth |
| Inflation Rate | Macro | Indicates purchasing power changes and monetary policy pressure |
| Unemployment Rate | Macro | Signals labor market strength and recessionary risk |
| Industrial Production | Macro | Captures real economic activity and output dynamics |
| Consumer Sentiment | Macro | Shows investor/consumer confidence which may influence market returns |
| VIX | Financial | Measures market volatility and risk appetite |
| Oil Price | Financial | Affects production costs, inflation expectations, and macro uncertainty |


--

I would particularly point out the NFCI variable. NFCI (National Financial Conditions Index) summarizes the overall tightness or looseness of U.S. financial conditions by combining over 100 credit, risk, and liquidity indicators. Although it is not a standard predictor in many basic return models, its ability to capture broad financial stress conditions makes it a valuable indicator for predicting stock returns. It provides information that is not fully reflected in traditional macro variables.

---
# Data

### Table: Possible Data Related to Stock Returns

| Variable | Type | Reason |
|----------------|------------|-----------------------|
| Corporate Bond Spread | Financial | Reflects credit risk and financial stress conditions |
| Yield Spread (10Y–3M) | Macro | Known recession predictor; captures term structure expectations. |
| NFCI (Financial Conditions) | Macro | Summarizes liquidity, credit, and financial stress in the economy |


---
# Model

Beyond linear model, I also used a LASSO model for the analysis.

The LASSO model is a regularized linear model that applies an L1 penalty to shrink coefficients and perform variable selection.

This technique helps prevent over-fitting and improves out-of-sample performance, especially when predictors are highly correlated.

There are some considerations for the LASSO model, including the choice of the regularization strength λ, which is selected through cross-validation to balance bias and variance.


---
# Main Result




```
## [1] "The OOS R^2 for the OLS is:  -0.332241919027255"
```

```
## [1] "The OOS R^2 for the LASSO is:  0.1604239532922"
```

&lt;img src="Presentation---Copy_files/figure-html/unnamed-chunk-1-1.png" style="display: block; margin: auto;" /&gt;


---

class: inverse, center, middle


### Disclaimer: I have used ChatGPT to assist me with debugging steps, resolving errors, and correctly implement the Training-Validation-Testing split. It also helpd me make some of my codes more efficient. 


---
&lt;html&gt;&lt;div style='float:left'&gt;&lt;/div&gt;&lt;hr color='#EB811B' size=1px width=796px&gt;&lt;/html&gt;



    </textarea>
<style data-target="print-only">@media screen {.remark-slide-container{display:block;}.remark-slide-scaler{box-shadow:none;}}</style>
<script src="https://remarkjs.com/downloads/remark-latest.min.js"></script>
<script>var slideshow = remark.create({
  "highlightStyle": "github",
  "highlightLines": true,
  "countIncrementalSlides": false
});
if (window.HTMLWidgets) slideshow.on('afterShowSlide', function (slide) {
  window.dispatchEvent(new Event('resize'));
});
(function(d) {
  var s = d.createElement("style"), r = d.querySelector(".remark-slide-scaler");
  if (!r) return;
  s.type = "text/css"; s.innerHTML = "@page {size: " + r.style.width + " " + r.style.height +"; }";
  d.head.appendChild(s);
})(document);

(function(d) {
  var el = d.getElementsByClassName("remark-slides-area");
  if (!el) return;
  var slide, slides = slideshow.getSlides(), els = el[0].children;
  for (var i = 1; i < slides.length; i++) {
    slide = slides[i];
    if (slide.properties.continued === "true" || slide.properties.count === "false") {
      els[i - 1].className += ' has-continuation';
    }
  }
  var s = d.createElement("style");
  s.type = "text/css"; s.innerHTML = "@media print { .has-continuation { display: none; } }";
  d.head.appendChild(s);
})(document);
// delete the temporary CSS (for displaying all slides initially) when the user
// starts to view slides
(function() {
  var deleted = false;
  slideshow.on('beforeShowSlide', function(slide) {
    if (deleted) return;
    var sheets = document.styleSheets, node;
    for (var i = 0; i < sheets.length; i++) {
      node = sheets[i].ownerNode;
      if (node.dataset["target"] !== "print-only") continue;
      node.parentNode.removeChild(node);
    }
    deleted = true;
  });
})();
// add `data-at-shortcutkeys` attribute to <body> to resolve conflicts with JAWS
// screen reader (see PR #262)
(function(d) {
  let res = {};
  d.querySelectorAll('.remark-help-content table tr').forEach(tr => {
    const t = tr.querySelector('td:nth-child(2)').innerText;
    tr.querySelectorAll('td:first-child .key').forEach(key => {
      const k = key.innerText;
      if (/^[a-z]$/.test(k)) res[k] = t;  // must be a single letter (key)
    });
  });
  d.body.setAttribute('data-at-shortcutkeys', JSON.stringify(res));
})(document);
(function() {
  "use strict"
  // Replace <script> tags in slides area to make them executable
  var scripts = document.querySelectorAll(
    '.remark-slides-area .remark-slide-container script'
  );
  if (!scripts.length) return;
  for (var i = 0; i < scripts.length; i++) {
    var s = document.createElement('script');
    var code = document.createTextNode(scripts[i].textContent);
    s.appendChild(code);
    var scriptAttrs = scripts[i].attributes;
    for (var j = 0; j < scriptAttrs.length; j++) {
      s.setAttribute(scriptAttrs[j].name, scriptAttrs[j].value);
    }
    scripts[i].parentElement.replaceChild(s, scripts[i]);
  }
})();
(function() {
  var links = document.getElementsByTagName('a');
  for (var i = 0; i < links.length; i++) {
    if (/^(https?:)?\/\//.test(links[i].getAttribute('href'))) {
      links[i].target = '_blank';
    }
  }
})();
// adds .remark-code-has-line-highlighted class to <pre> parent elements
// of code chunks containing highlighted lines with class .remark-code-line-highlighted
(function(d) {
  const hlines = d.querySelectorAll('.remark-code-line-highlighted');
  const preParents = [];
  const findPreParent = function(line, p = 0) {
    if (p > 1) return null; // traverse up no further than grandparent
    const el = line.parentElement;
    return el.tagName === "PRE" ? el : findPreParent(el, ++p);
  };

  for (let line of hlines) {
    let pre = findPreParent(line);
    if (pre && !preParents.includes(pre)) preParents.push(pre);
  }
  preParents.forEach(p => p.classList.add("remark-code-has-line-highlighted"));
})(document);</script>

<script>
slideshow._releaseMath = function(el) {
  var i, text, code, codes = el.getElementsByTagName('code');
  for (i = 0; i < codes.length;) {
    code = codes[i];
    if (code.parentNode.tagName !== 'PRE' && code.childElementCount === 0) {
      text = code.textContent;
      if (/^\\\((.|\s)+\\\)$/.test(text) || /^\\\[(.|\s)+\\\]$/.test(text) ||
          /^\$\$(.|\s)+\$\$$/.test(text) ||
          /^\\begin\{([^}]+)\}(.|\s)+\\end\{[^}]+\}$/.test(text)) {
        code.outerHTML = code.innerHTML;  // remove <code></code>
        continue;
      }
    }
    i++;
  }
};
slideshow._releaseMath(document);
</script>
<!-- dynamically load mathjax for compatibility with self-contained -->
<script>
(function () {
  var script = document.createElement('script');
  script.type = 'text/javascript';
  script.src  = 'https://mathjax.rstudio.com/latest/MathJax.js?config=TeX-MML-AM_CHTML';
  if (location.protocol !== 'file:' && /^https?:/.test(script.src))
    script.src  = script.src.replace(/^https?:/, '');
  document.getElementsByTagName('head')[0].appendChild(script);
})();
</script>
  </body>
</html>
